set nobackup
set cursorcolumn
colorscheme new-railscasts
set pyx=3

let g:indent_guides_auto_colors = 0
" Set split separator to Unicode box drawing character
set encoding=utf8
set fillchars=vert:│

" Uses tpope's vim-sensible defaults
set hidden
set notimeout
set noswapfile
set nowritebackup
set nowrap
set nofoldenable
set lazyredraw
set number
set expandtab
set ignorecase
set smartcase
set noshowmode
set modeline
set nospell

if has('nvim-0.4')
  set pumblend=22
  set winblend=15
  set wildoptions+=pum,tagfile
  :hi PmenuSel blend=5
  set pumheight=15
endif

autocmd BufRead,BufNewFile *.html.erb set filetype=eruby.html
autocmd BufRead,BufNewFile *.html.eex set filetype=eelixir.html
autocmd BufRead,BufNewFile *.scss set filetype=scss.css

" Disable arrows keys
noremap   <Up>     <NOP>
noremap   <Down>   <NOP>
noremap   <Left>   <NOP>
noremap   <Right>  <NOP>

" Little tricks
nnoremap <bs> <c-^>
set undofile

let g:bubbly_palette = #{
\   background: "#34343c",
\   foreground: "#c5cdd9",
\   black: "#3e4249",
\   red: "#ec7279",
\   green: "#a0c980",
\   yellow: "#deb974",
\   blue: "#6cb6eb",
\   purple: "#d38aea",
\   cyan: "#5dbbc1",
\   white: "#c5cdd9",
\   lightgrey: "#57595e",
\   darkgrey: "#404247",
\ }

let g:bubbly_tabline = 0
let g:bubbly_inactive_style = 'italic'
let g:bubbly_statusline = ['mode', 'truncate', 'path', 'branch', 'signify', 'coc', 'divisor', 'filetype', 'progress']

let g:gitblame_date_format = '%d/%m/%Y %H:%M'

" Fix error for any line plugin
let g:bufferline_echo = 0

" TmuxNavigator
let g:tmux_navigator_save_on_switch = 1
let g:tmux_navigator_disable_when_zoomed = 1

" Nvim tree
let g:nvim_tree_follow = 1
let g:nvim_tree_width = 35
let g:nvim_tree_group_empty = 1
let g:nvim_tree_highlight_opened_files = 2

" ALE
let g:ale_use_global_executables = 1
let g:ale_set_highlights = 0
let g:ale_completion_enabled = 1
let g:ale_completion_max_suggestions = 10
let g:ale_lint_on_enter = 1
let g:ale_lint_on_filetype_changed = 0
let g:ale_lint_on_save = 1
let g:ale_lint_on_text_changed = 'never'
let g:ale_sign_column_always = 0
let g:ale_sign_error=''
let g:ale_sign_info=''
let g:ale_sign_style_error=''
let g:ale_sign_style_warning=''
let g:ale_sign_warning=''
let g:ale_statusline_format = [' %d', ' %d', ' %d']
nmap ]a <Plug>(ale_next_wrap)
nmap [a <Plug>(ale_previous_wrap)
nmap <leader>f <Plug>(ale_fix)
let g:ale_linters = {
  \ 'css': ['stylelint', 'prettier'],
  \ 'elixir': ['credo'],
  \ 'eruby': ['erb', 'erubis'],
  \ 'haml': ['hamllint'],
  \ 'handlebars': ['ember-template-lint'],
  \ 'html': [],
  \ 'javascript': ['eslint', 'tsserver'],
  \ 'json': ['prettier'],
  \ 'lua': ['luac', 'luacheck'], 
  \ 'ruby': ['rubocop', 'ruby'],
  \ 'scss': ['stylelint', 'prettier'],
  \ 'typescript': ['tslint', 'typecheck', 'tsserver'],
  \ 'vim': ['vint'],
  \ 'vue': ['vls', 'eslint'],
  \}

let g:ale_fixers = {
  \ '*': ['remove_trailing_lines', 'trim_whitespace'],
  \ 'css': ['stylelint', 'prettier'],
  \ 'elixir': ['mix_format'],
  \ 'javascript': ['prettier', 'eslint'],
  \ 'json': ['prettier'],
  \ 'lua': ['lua-format'],
  \ 'markdown': ['prettier'],
  \ 'ruby': ['prettier', 'rubocop'],
  \ 'scss': ['stylelint'],
  \ 'typescript': ['prettier', 'tslint'],
  \ 'vue': ['prettier'],
  \ 'yaml': ['prettier'],
  \ 'html': ['prettier'],
  \ 'haml': ['prettier'],
  \ 'eruby': ['prettier']
  \}

let g:ale_floating_preview = 1

" Signify
let g:signify_cursorhold_insert = 1
let g:signify_cursorhold_normal = 1
let g:signify_disable_by_default = 0
let g:signify_sign_add = '✚'
let g:signify_sign_change = ''
let g:signify_sign_delete = '✖'
let g:signify_sign_delete_first_line = '﫨'
let g:signify_update_on_bufenter = 1
let g:signify_update_on_focusgained = 1
let g:signify_sign_delete_first_line = '-'

nmap <silent> <leader>pd :SignifyHunkDiff<CR>
nmap <silent> <leader>pu :SignifyHunkUndo<CR>

" Text Formatting/Layout
set autoindent " auto-indent
set expandtab  " use spaces instead of tabs
set shiftround " always indent/outdent to the nearest tabstop
set smarttab   " use tabs at the start of a line, spaces elsewhere

" elixir config
let g:elixir_use_markdown_for_docs = 1

" Easier split navigations https://robots.thoughtbot.com/vim-splits-move-faster-and-more-naturally
nnoremap <C-H> <C-W><C-H>
nnoremap <C-J> <C-W><C-J>
nnoremap <C-K> <C-W><C-K>
nnoremap <C-L> <C-W><C-L>
set splitbelow
set splitright

" Make it obvious where 80 characters is
set textwidth=120
set colorcolumn=+1
let &colorcolumn = '80,' . join(range(120, 999), ',')

" Vim-grepper
nnoremap <leader>ag  :Grepper -tool rg -open -switch<cr>
nnoremap <Leader>* :Grepper -tool rg -cword -noprompt<CR>
nmap gr <plug>(GrepperOperator)
xmap gr <plug>(GrepperOperator)
nnoremap <leader>// :Grepper <cr>
let g:grepper               = {}
let g:grepper.tools         = ['rg', 'git']
" redefines the rg with defaults and only adds smart-case
let g:grepper.rg = {
    \ 'grepprg': 'rg -H --smart-case --no-heading --vimgrep' . (has('win32') ? ' $* .' : ''),
    \ 'grepformat': '%f:%l:%c:%m,%f',
    \ 'escape':      '\^$.*+?()[]{}|' ,
    \ }
let g:grepper.highlight = 1
"" Grep for TODO
command! Todo Grepper -noprompt -tool git -query -E '(TODO|FIXME|XXX):'

" save files
nnoremap <c-s> :w<CR>
inoremap <c-s> <Esc>:w<CR>
vnoremap <c-s> <Esc>:w<CR>

" vim test plugin
let g:test#strategy = 'tslime'
nmap <silent> <leader>tn :TestNearest<CR>
nmap <silent> <leader>tf :TestFile<CR>
nmap <silent> <leader>ta :TestSuite<CR>
nmap <silent> <leader>tl :TestLast<CR>
nmap <silent> <leader>tv :TestVisit<CR>

" let g:test#javascript#mocha#executable = 'NODE_ENV=test mocha'
" let test#ruby#rspec#executable = 'docker-compose exec -e RAILS_ENV=test -e BEAR_LOG_LEVEL=debug app rspec'
let g:test#elixir#exunit#options = {
  \ 'nearest': '--trace --color',
  \ 'file':    '--trace --color',
  \ 'suite':   '--trace --color',
\}

" tslime configs
let g:tslime_always_current_session = 1
let g:tslime_always_current_window = 1
vmap <C-c><C-c> <Plug>SendSelectionToTmux
nmap <C-c><C-c> <Plug>NormalModeSendToTmux
nmap <C-c>r <Plug>SetTmuxVars

" dash integration
nmap <silent> <leader>d <Plug>DashSearch

" Auto tags generation
map <Leader>ct :call atags#generate()<cr>

" coc-snipets
inoremap <silent><expr> <TAB>
      \ pumvisible() ? coc#_select_confirm() :
      \ coc#expandableOrJumpable() ? "\<C-r>=coc#rpc#request('doKeymap', ['snippets-expand-jump',''])\<CR>" :
      \ <SID>check_back_space() ? "\<TAB>" :
      \ coc#refresh()

function! s:check_back_space() abort
  let col = col('.') - 1
  return !col || getline('.')[col - 1]  =~# '\s'
endfunction

let g:coc_snippet_next = '<tab>'

" Cursor: block in normal/visual, vertical blinking in insert/command, horizontal blinking in replace/operator pending
if has('nvim')
    let &guicursor = 'n-v-c-sm:block-Cursor-blinkon0,'
        \          . 'i-c-ci-ve:ver25-blinkwait1000-blinkon500-blinkoff500,'
        \          . 'r-cr-o:hor20-blinkwait1000-blinkon500-blinkoff500'
endif

" move lines in visual mode
vnoremap J :m '>+1<CR>gv=gv
vnoremap K :m '<-2<CR>gv=gv

" gutentags
let g:gutentags_generate_on_write = 0 " Disabled on extreme big monolitics

" FZF integration
let g:fzf_colors =
  \ { 'fg':      ['fg', 'Normal'],
  \   'bg':      ['bg', 'Normal'],
  \   'hl':      ['fg', 'Comment'],
  \   'fg+':     ['fg', 'CursorLine', 'CursorColumn', 'Normal'],
  \   'bg+':     ['bg', 'CursorLine', 'CursorColumn'],
  \   'hl+':     ['fg', 'Statement'],
  \   'info':    ['fg', 'PreProc'],
  \   'border':  ['fg', 'Ignore'],
  \   'prompt':  ['fg', 'Conditional'],
  \   'pointer': ['fg', 'Exception'],
  \   'marker':  ['fg', 'Keyword'],
  \   'spinner': ['fg', 'Label'],
  \   'header':  ['fg', 'Comment']
  \ }

let g:fzf_history_dir = '~/.local/share/fzf-history'

function! FZFOpen(command_str)
  if (expand('%') =~# 'NERD_tree' && winnr('$') > 1)
    exe "normal! \<c-w>\<c-w>"
  endif
  exe 'normal! ' . a:command_str . "\<cr>"
endfunction

nnoremap <silent> <C-c> :Commands<CR>
nnoremap <silent> <C-p> :<C-u>CocCommand fzf-preview.ProjectFiles<CR>
nnoremap <silent> <C-t> :<C-u>CocCommand fzf-preview.AllBuffers<CR>
nnoremap <silent> <leader>; :BLines<CR>
nnoremap <silent> <leader>? :History<CR>
nnoremap <silent> <leader>A :Windows<CR>
nnoremap <silent> <leader>O :BTags<CR>
nnoremap <silent> <leader>ft :Filetypes<CR>
nnoremap <silent> <leader>ga :BCommits<CR>
nnoremap <silent> <leader>gl :Commits<CR>
nnoremap <silent> <leader>m :Maps<CR>
nnoremap <silent> <leader>o :<C-u>CocCommand fzf-preview.Ctags<CR>
nnoremap <silent> F :<C-u>CocCommand fzf-preview.ProjectGrep  .<CR>
xnoremap <silent> F "sy:FzfPreviewProjectGrep<Space>.<Space>-F<Space>-add-fzf-arg=--query="<C-r>=substitute(substitute(@s, '\n', '', 'g'), '/', '\\/', 'g')<CR>"<CR>
nnoremap <silent> <leader>M :<C-u>FzfPreviewProjectMruFiles<CR>
nnoremap <silent> <leader>b :<C-u>CocCommand fzf-preview.Bookmarks<CR>

" fzf_preview
let g:fzf_layout = { 'window': { 'width': 0.7, 'height': 0.95 } }
let g:coc_fzf_preview = 'right:60%'
let g:fzf_preview_window = 'right:60%'
let g:fzf_preview_use_dev_icons = 1
let g:fzf_preview_filelist_command = 'rg --files --no-ignore-vcs --smart-case --hidden --follow --no-messages --ignore-file $HOME/.ignore'
let g:fzf_preview_if_binary_command = '[[ "$(file --mime {})" =~ binary ]]'
" let g:fzf_preview_floating_window_winblend = 10
let g:fzf_preview_command = 'bat --color=always --style=full {-1}'
let g:fzf_preview_floating_window_rate = 0.95
let g:fzf_preview_direct_window_option = ''
let g:fzf_preview_default_fzf_options = { '--preview-window': 'wrap:60%' }
let g:fzf_preview_dev_icons_limit = 5000

nnoremap <silent> <leader>s :<C-u>call system('say ' . expand('<cword>'))<CR>

let g:closetag_filenames = '*.html,*.xhtml,*.phtml,*.hbs,*.xml,*.vue'

nnoremap <silent> Q :Bdelete menu<CR>

let g:mustache_abbreviations = 1

" AndrewRadev/ember_tools.vim
let g:ember_tools_highlight_actions = 0

" Configure node, python executable
let g:node_host_prog = '/Users/carakan/.asdf/installs/nodejs/14.15.3/.npm/lib/node_modules/neovim/bin/cli.js'
let g:bookmark_sign = ''

vmap <leader>y :YankCode<CR>

lua <<EOF
require("bufferline").setup(
    {
        options = {
            view = "multiwindow",
            numbers = "none",
            number_style = "",
            mappings = false,
            buffer_close_icon = "",
            modified_icon = "",
            close_icon = "",
            left_trunc_marker = "",
            right_trunc_marker = "",
            max_name_length = 25,
            tab_size = 25,
            show_tab_indicators = true,
            show_buffer_close_icons = true,
            separator_style = "slant",
            always_show_bufferline = true,
            sort_by = 'tabs'
        },
        highlights = {
            background = {
                guifg = "#3e4451",
                guibg = "#181621"
            },
            fill = {
                guifg = "#181621",
                guibg = "#181621"
                -- guibg = "NONE"
            },
            buffer_selected = {
                guifg = "#d6d1c7",
                guibg = "#282c34",
                gui = "bold"
            },
            buffer_visible = {
                guifg = "#564b3a",
                guibg = "#181621",
                gui = "italic,bold"
            },
            separator_visible = {
                guifg = "#282c34",
                guibg = "#181621"
            },
            separator_selected = {
                guifg = "#181621",
                guibg = "#282c34"
            },
            indicator_selected = {
                guifg = "#ccaaff",
                guibg = "#282c34"
            },
            modified_selected = {
                guifg = "#ffffff",
                guibg = "#282c34"
            }
        }
    }
)
require('hlslens').setup({
  override_lens = function(render, plist, nearest, idx, r_idx)
    local sfw = vim.v.searchforward == 1
    local indicator, text, chunks
    local abs_r_idx = math.abs(r_idx)
    if abs_r_idx > 1 then
      indicator = ('%d%s'):format(abs_r_idx, sfw ~= (r_idx > 1) and '▲' or '▼')
    elseif abs_r_idx == 1 then
      indicator = sfw ~= (r_idx == 1) and '▲' or '▼'
    else
      indicator = ''
    end
    local lnum, col = unpack(plist[idx])
    if nearest then
      local cnt = #plist
      if indicator ~= '' then
        text = ('[%s %d/%d]'):format(indicator, idx, cnt)
      else
        text = ('[%d/%d]'):format(idx, cnt)
      end
      chunks = {{' ', 'Ignore'}, {text, 'HlSearchLensNear'}}
    else
      text = ('[%s %d]'):format(indicator, idx)
      chunks = {{' ', 'Ignore'}, {text, 'HlSearchLens'}}
    end
    render.set_virt(0, lnum - 1, col - 1, chunks, nearest)
  end
})
require('indent_guides').setup({
  indent_levels = 30;
  indent_guide_size = 1;
  indent_start_level = 2;
  indent_space_guides = true;
  indent_tab_guides = true;
  indent_soft_pattern = '\\s';
  exclude_filetypes = {'help','dashboard','dashpreview','NvimTree','vista','sagahover'};
  odd_colors = { fg ='#332717',bg='#332b36' };
  even_colors = {fg='#332b36',bg='#332717'};
})
require('bqf').setup({
    auto_enable = true,
    preview = {
        win_height = 12,
        win_vheight = 12,
        delay_syntax = 80,
        border_chars = {'│', '│', '─', '─', '╭', '╮', '╰', '╯', '█'}
    },
    func_map = {
        vsplit = '',
        ptogglemode = 'z,',
        stoggleup = ''
    },
    filter = {
        fzf = {
            action_for = {['ctrl-s'] = 'split'},
            extra_opts = {'--bind', 'ctrl-o:toggle-all', '--prompt', '> '}
        }
    }
})
require('numb').setup()

local custom_onedark = require'lualine.themes.onedark'
custom_onedark.normal.b.bg = '#444444'
custom_onedark.normal.c.bg = '#444444'
custom_onedark.normal.c.fg = '#bfbbae'
custom_onedark.normal.c.gui = 'bold'
custom_onedark.inactive.b.bg = '#353535'
custom_onedark.inactive.c.bg = '#353535'
custom_onedark.inactive.c.fg = '#a8a494'

require'lualine'.setup {
  options = {
    icons_enabled = true,
    theme = custom_onedark,
    component_separators = {'', ''},
    section_separators = {'', ''},
    disabled_filetypes = {}
  },
  sections = {
    lualine_a = {'mode'},
    lualine_b = {'branch', "diff"},
    lualine_c = {{'filename', path = 1 }},
    lualine_x = {'encoding', 'fileformat', 'filetype', 'g:coc_status'},
    lualine_y = {'progress'},
    lualine_z = {'location'}
  },
  inactive_sections = {
    lualine_a = {},
    lualine_b = {},
    lualine_c = {{'filename', path = 1, color = { gui = 'italic,bold' }}},
    lualine_x = {'location'},
    lualine_y = {},
    lualine_z = {}
  },
  tabline = {},
  extensions = {'fzf', 'fugitive', 'nvim-tree', 'quickfix'},
}
require 'nvim-treesitter.configs'.setup {
    ensure_installed = {
      'bash', 'css', 'comment', 'dockerfile', 'elixir', 'erlang', 'glimmer', 'html', 'javascript', 'jsonc', 
      'lua', 'php', 'python', 'regex', 'ruby', 'rust', 'scss', 'toml', 'tsx', 'typescript', 'vue', 'yaml'
    },
    highlight = {
        enable = true,
    },
    playground = {
        enable = true,
        disable = {},
        updatetime = 25, -- debounced time for highlighting nodes in teh playground from source code
        persist_queries = false, -- Whether the query persists across vim sessions
    },
    autotag = {
        enable = true,
    },
  incremental_selection = {
    enable = true,
    keymaps = {
      init_selection = "gnn",
      node_incremental = "grn",
      scope_incremental = "grc",
      node_decremental = "grm",
    },
  },
  indent = {
    enable = true
  },
  folding = { enable = true }
}
EOF
hi BqfPreviewBorder guifg=#385075
hi link BqfPreviewRange Search
hi default link HlSearchLensNear Search
hi default link HlSearchLens ALEInfoSign
hi HlSearchNear guibg=#1b3577 guifg=#FFC66D gui=bold,italic

" Debug highlight
nmap <silent> <leader>is :TSHighlightCapturesUnderCursor<CR>

let g:vimade = {}
let g:vimade.fadelevel = 0.7
let g:vimade.enablesigns = 1
let g:vimade.enablefocusfading = 1

let g:Hexokinase_optInPatterns = [
\     'full_hex',
\     'triple_hex',
\     'rgb',
\     'rgba',
\     'hsl',
\     'hsla',
\     'colour_names'
\ ]
let g:Hexokinase_ftOptInPatterns = {
\     'css': 'full_hex,triple_hex,rgb,rgba,hsl,hsla,colour_names',
\     'html': 'full_hex,rgb,rgba,hsl,hsla',
\     'javascript': 'full_hex,rgb,rgba,hsl,hsla'
\ }
let g:Hexokinase_virtualText = '     ██████'

let g:matchup_matchparen_offscreen = {'method': 'popup'}
let g:matchup_matchparen_deferred = 1
let g:matchup_matchparen_hi_surround_always = 1
:hi MatchParen guibg=#422200 gui=bold,italic guifg=NONE blend=25
:hi HighlightedyankRegion guibg=#482d00 blend=25

let g:qs_highlight_on_keys = ['f', 't', 'T']

" Coc Configuration
let g:coc_default_semantic_highlight_groups = 1
let g:coc_global_extensions = [
  \ 'coc-css',
  \ 'coc-cssmodules',
  \ 'coc-emoji',
  \ 'coc-fzf-preview',
  \ 'coc-highlight',
  \ 'coc-html',
  \ 'coc-json',
  \ 'coc-lists',
  \ 'coc-lua',
  \ 'coc-markdownlint',
  \ 'coc-sh',
  \ 'coc-snippets',
  \ 'coc-solargraph',
  \ 'coc-styled-components',
  \ 'coc-tag',
  \ 'https://github.com/rodrigore/coc-tailwind-intellisense',
  \ 'coc-tsserver',
  \ 'coc-vetur',
  \ 'coc-vimlsp',
  \ 'coc-word',
  \ 'coc-yaml'
\ ]
" Use <c-space> to trigger completion.
inoremap <silent><expr> <c-space> coc#refresh()

" Use `[c` and `]c` to navigate diagnostics
nmap <silent> [c <Plug>(coc-diagnostic-prev)
nmap <silent> ]c <Plug>(coc-diagnostic-next)

" Remap keys for gotos
nmap <silent> gd <Plug>(coc-definition)
nmap <silent> gy <Plug>(coc-type-definition)
nmap <silent> gi <Plug>(coc-implementation)
nmap <silent> gr <Plug>(coc-references)

vmap <leader>a <Plug>(coc-codeaction)
nmap <leader>a <Plug>(coc-codeaction)

nnoremap <Leader>mf :CocCommand markdownlint.fixAll<CR>

" Use K to show documentation in preview window
nnoremap <silent> K :call <SID>show_documentation()<CR>

function! s:show_documentation()
  if (index(['vim','help'], &filetype) >= 0)
    execute 'h '.expand('<cword>')
  else
    call CocAction('doHover')
  endif
endfunction

" Remap for rename current word
nmap <leader>rn <Plug>(coc-rename)

let g:vue_pre_processors = []

" projectionist
if !exists('g:rails_projections')
let g:rails_projections = {
  \  "app/models/*.rb": {
  \     "test": [
  \       "spec/models/{}_spec.rb",
  \       "test/models/{}_test.rb"
  \     ],
  \     "alternate": [
  \       "spec/models/{}_spec.rb",
  \       "test/models/{}_test.rb"
  \     ],
  \   },
  \  "app/controllers/*_controller.rb": {
  \     "test": [
  \       "spec/controllers/{}_controller_spec.rb",
  \       "test/controllers/{}_controller_test.rb",
  \       "spec/requests/{}_spec.rb"
  \     ],
  \     "alternate": [
  \       "spec/controllers/{}_controller_spec.rb",
  \       "test/controllers/{}_controller_test.rb",
  \       "spec/requests/{}_spec.rb"
  \     ],
  \   },
  \   "app/services/*.rb": {
  \     "command": "service",
  \     "test": [
  \       "spec/services/%s_spec.rb",
  \       "test/services/%s_test.rb"
  \     ],
  \     "alternate": [
  \       "spec/services/{}_spec.rb",
  \       "test/services/{}_test.rb"
  \     ],
  \     "template": [
  \       "class {camelcase|capitalize|colons}Service",
  \       "end"
  \     ]
  \   },
  \   "app/queries/*_query.rb": {
  \     "command": "query",
  \     "test": [
  \       "spec/queries/%s_spec.rb",
  \       "test/queries/%s_test.rb"
  \     ],
  \   },
  \   "spec/requests/*_spec.rb": {
  \     "template": [
  \       "require 'rails_helper'",
  \       "",
  \       "RSpec.describe \"{underscore|capitalize|blank}\", type: :request do",
  \       "end"
  \     ],
  \     "type": "integration test"
  \   },
  \  "spec/controllers/*_spec.rb": {
  \    "command": "controller",
  \    "alternate": "app/controllers/{}_controller.rb",
  \    "template": [
  \      "require 'rails_helper'",
  \      "",
  \      "RSpec.describe {camelcase|capitalize|colons}, type: :controller do",
  \      "end"
  \    ]
  \   },
  \  "spec/models/*_spec.rb": {
  \    "command": "model",
  \    "alternate": "app/models/{}.rb",
  \    "template": [
  \      "require 'rails_helper'",
  \      "",
  \      "RSpec.describe {camelcase|capitalize|colons}, type: :model do",
  \      "end"
  \    ]
  \   },
  \  "spec/services/*_spec.rb": {
  \    "command": "services",
  \    "alternate": "app/services/{}.rb",
  \    "template": [
  \      "require 'rails_helper'",
  \      "",
  \      "RSpec.describe {camelcase|capitalize|colons} do",
  \      "end"
  \    ]
  \   },
  \   "spec/features/*_spec.rb": { "command": "feature" },
  \ }
endif

let g:projectionist_heuristics = {
  \  "&mix.exs": {
  \    "lib/*.ex": {
  \      "type": "lib",
  \      "alternate": [
  \        "spec/{}_spec.exs",
  \        "test/{}_test.exs",
  \      ],
  \    },
  \    "spec/*_spec.exs": {
  \      "type": "spec",
  \      "alternate": "lib/{}.ex",
  \      "dispatch": "mix espec spec/{}_spec.exs`=v:lnum ? ':'.v:lnum : ''`"
  \    },
  \    "spec/spec_helper.exs": { "type": "spec" },
  \    "test/*_test.exs": {
  \      "type": "test",
  \      "alternate": "lib/{}.ex",
  \      "dispatch": "mix test test/{}_test.exs`=v:lnum ? ':'.v:lnum : ''`"
  \    },
  \    "test/test_helper.exs": { "type": "test" },
  \    "mix.exs": {
  \      "type": "lib",
  \      "alternate": "mix.lock",
  \      "dispatch": "mix deps.get"
  \    },
  \    "mix.lock": { "alternate": "mix.exs" },
  \    "*": {
  \      "make": "mix",
  \      "console": "iex -S mix"
  \    }
  \  },
  \ "ember-cli-build.js": {
  \   "app/routes/*.js": {
  \     "type": "route",
  \     "template": [
  \       "import Ember from 'ember';",
  \       "",
  \       "export default Ember.Route.extend({",
  \       "});",
  \     ],
  \     "alternate": "app/templates/{}.hbs"
  \   },
  \   "app/controllers/*.js": {
  \     "type": "controller",
  \     "template": [
  \       "import Ember from 'ember';",
  \       "",
  \       "export default Ember.Controller.extend({",
  \       "});",
  \     ],
  \     "alternate": "app/templates/{}.hbs"
  \   },
  \   "app/templates/components/*.hbs": {
  \     "alternate": "tests/integration/components/{}-test.js"
  \   },
  \   "app/components/*.js": {
  \     "type": "component",
  \     "template": [
  \       "import Ember from 'ember';",
  \       "",
  \       "export default Ember.Component.extend({",
  \       "});",
  \     ],
  \     "alternate": "app/templates/components/{}.hbs"
  \   },
  \   "app/templates/*.js": {
  \     "type": "template",
  \     "template": [
  \       "{{outlet}}",
  \     ]
  \   },
  \   "app/mixins/*.js": {
  \     "type": "mixin",
  \     "template": [
  \       "import Ember from 'ember';",
  \       "",
  \       "export default Ember.Mixin.create({",
  \       "});",
  \     ],
  \   },
  \   "app/models/*.js": {
  \     "type": "model",
  \     "template": [
  \       "import DS from 'ember-data';",
  \       "",
  \       "export default DS.Model.extend({",
  \       "});",
  \     ],
  \     "alternate": "app/adapters/{}.js"
  \   },
  \   "app/adapters/*.js": {
  \     "type": "adapter",
  \     "template": [
  \       "import ApplicationAdapter from './application';",
  \       "",
  \       "export default ApplicationAdapter.extend({",
  \       "});",
  \     ],
  \     "alternate": "app/serializers/{}.js"
  \   },
  \   "app/services/*.js": {
  \     "type": "service",
  \     "template": [
  \       "import Ember from 'Ember';",
  \       "",
  \       "export default Ember.Service.extend({",
  \       "});",
  \     ],
  \   },
  \   "app/serializers/*.js": {
  \     "type": "serializer",
  \     "template": [
  \       "import ApplicationSerializer from './application';",
  \       "",
  \       "export default ApplicationSerializer.extend({",
  \       "});",
  \     ],
  \     "alternate": "app/models/{}.js"
  \   },
  \   "app/mirage/factories/*.js": {
  \     "type": "factory",
  \     "template": [
  \       "import Mirage from 'ember-cli-mirage';",
  \       "",
  \       "export default Mirage.Factory.extend({",
  \       "});",
  \     ],
  \     "alternate": "app/models/{}.js"
  \   },
  \   "tests/unit/models/*-test.js": {
  \     "alternate": "app/models/{}.js"
  \   },
  \   "tests/integration/components/*-test.js": {
  \     "alternate": "app/components/{}.js"
  \   },
  \ },
  \ }

let g:lens#disabled_filetypes = ['NvimTree', 'fzf', 'coc-explorer', 'qf', '']
let g:lens#animate = 0
let g:lens#height_resize_max = 50
let g:lens#height_resize_min = 15
let g:lens#width_resize_max = 130
let g:lens#width_resize_min = 80

command! -bang -nargs=* Find call fzf#vim#grep('rg --column --line-number --no-heading --fixed-strings --follow --hidden --glob "!{.git/*,*.lock}" --color "always" -- ' . shellescape(<q-args>), 1, <bang>0)
